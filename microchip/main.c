// PIC32MX150F128D Configuration Bit Settings

// 'C' source line config statements
// Automatically generated by MPLAB X

// DEVCFG3
// USERID = No Setting
#pragma config PMDL1WAY = ON            // Peripheral Module Disable Configuration (Allow only one reconfiguration)
#pragma config IOL1WAY = ON             // Peripheral Pin Select Configuration (Allow only one reconfiguration)

// DEVCFG2
#pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
#pragma config FPLLMUL = MUL_20         // PLL Multiplier (20x Multiplier)
#pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)

// DEVCFG1
#pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
#pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
#pragma config IESO = ON                // Internal/External Switch Over (Enabled)
#pragma config POSCMOD = XT             // Primary Oscillator Configuration (XT osc mode)
#pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
#pragma config FPBDIV = DIV_2           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/2)
#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
#pragma config WDTPS = PS1048576        // Watchdog Timer Postscaler (1:1048576)
#pragma config WINDIS = OFF             // Watchdog Timer Window Enable (Watchdog Timer is in Non-Window Mode)
#pragma config FWDTEN = ON              // Watchdog Timer Enable (WDT Enabled)
#pragma config FWDTWINSZ = WINSZ_25     // Watchdog Timer Window Size (Window Size is 25%)

// DEVCFG0
#pragma config JTAGEN = ON              // JTAG Enable (JTAG Port Enabled)
#pragma config ICESEL = ICS_PGx1        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
#pragma config PWP = OFF                // Program Flash Write Protect (Disable)
#pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
#pragma config CP = OFF                 // Code Protect (Protection Disabled)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

#include <p32xxxx.h>

void delay (int n)
{
    n *= 1000;

    while (n --)
        asm volatile ("nop");
}

void main1 (void)
{
    TRISB = 0;  // Set all port B bits as outputs,
                // including one of LEDs on chipKit Cmod

    for (;;)
    {
        PORTB = ~ 0;
        delay (1000);
        PORTB = 0;
        delay (1000);
    }
}

//--------------------------------------------------------------------

void main2 (void)
{
    int n;
    
    TRISC = 0;  // Setting LEDs on breadboard as outputs connected to port C
    n     = 0x23;

    for (;;)
    {
        n = (n >> 1) | ((n & 1) << 7);
        PORTC = n << 2;
        delay (1000);
    }
}

//--------------------------------------------------------------------

void main3 (void)
{
    int i, n, m;
    
    TRISC = 0;
    
    i = 0;
    n = 1;
    m = 1;

    for (;;)
    {
        i ++;
        
        n = (n >> 1) | ((n & 1) << 7);
        
        if (i % 10 == 0)
            m = ((m << 1) & 0xff) | ((m & 0x80) >> 7);

        PORTC = (n | m) << 2;
        
        delay (300);
    }
}

//--------------------------------------------------------------------

void main4 (void)
{
    int n = 0;

    ANSELB = 0;  // Set all port B pins as digital, not analog

    TRISBbits.TRISB13 = 1;  // Input button
    TRISC             = 0;  // LEDs on breadboard

    for (;;)
    {
        n = n >> 1;
        
        if (PORTBbits.RB13)
           n |= 0x80;

        PORTC = n << 2;

        delay (500);
    }
}

//--------------------------------------------------------------------

#define SYS_CLK_FREQUENCY  (40 * 1000 * 1000)
#define PB_CLK_FREQUENCY   (20 * 1000 * 1000)
#define SPI_CLK_FREQUENCY  ( 2 * 1000 * 1000)  // Requirement: from 1 to 4 MHz

void main (void)
{
    unsigned spi_value, light_level, shift, output_value;

    // Re-map SPI bits
    
    RPC0R = 3;  // SS1_bar
    RPC1R = 3;  // SDO1
    SDI1R = 1;  // RPB5

    // Set GPIO RC bits 9:2 as outputs, 1:0 as inputs

    TRISC = 3;

    // Configure SPI

    SPI2CONbits.ON      = 0;        // Disable SPI to reset any previous state
    spi_value           = SPI2BUF;  // Clear receive buffer

    SPI1CONbits.MSTEN   = 1;        // Master Mode Enable bit
    SPI1CONbits.MSSEN   = 1;        // Slave Select pin is driven automatically
    SPI1CONbits.MODE16  = 1;        // 16-Bit Communication
    SPI1CONbits.DISSDO  = 1;        // Disable SDOx pin bit

//  SPI1CONbits.SRXISEL = 1;        // 01 = Interrupt is generated when the buffer is not empty

    SPI1BRG             = PB_CLK_FREQUENCY / SPI_CLK_FREQUENCY / 2 - 1;

    SPI1CONbits.ON      = 1;  // Enable SPI

    for (;;)
    {
        SPI1BUF = 0;  // send data to slave
        
        while (SPI1STATbits.SPIBUSY)   // wait until SPI transmission complete
            ;
            
        spi_value = SPI1BUF;
        
        light_level = spi_value >> 4;  // Eight bits of information
                                       // with four trailing zeroes
        
        shift = light_level >> 4;

        output_value = ~ (0xff >> shift);

        PORTC = output_value << 2;
    }
/*        
IFS1bits.SPI1EIF = 0;
IFS1bits.SPI1RXIF = 0;
IFS1bits.SPI1TXIF = 0;

IEC1bits.SPI1EIE = 0;
IEC1bits.SPI1RXIE = 0;
IEC1bits.SPI1TXIE = 0;

IPC7bits.SPI1IS = 0;
IPC7bits.SPI1IP = 0;
*/
}
